package Variable.projects;

public class Operations {

    /* 1) поразрядные операции*/

    void exampleMethod1(){

        System.out.println("Поразрядные операции!");

        /* поразрядные логические операции*/
        System.out.println("- Поразрядные логические операции: ");
        byte A = 34;
        byte B = 52;
        byte res;

        /* поразрядная логическая операция & (И)*/
        res = (byte)(A & B);
        System.out.println("поразрядная логическая операция & (И) A & B = "+res);

        /* поразрядная логическая операция | (ИЛИ)*/
        res = (byte)(A | B);
        System.out.println("поразрядная логическая операция | (ИЛИ) A | B = "+res);

        /* поразрядная логическая операция ^ (Исключающее ИЛИ)*/
        res = (byte)(A ^ B);
        System.out.println("поразрядная логическая операция ^ (Исключающее ИЛИ) A ^ B = "+res);

        /* унарная поразрядная операция ~ (НЕ)*/
        res = (byte) ~A;
        System.out.println("унарная поразрядная операция ~ (НЕ) ~A = "+res);
        System.out.println("----------\n");

        /* операции сдвига*/
        System.out.println("- Операции сдвига: ");
        /* значения типа byte, short и char перед сдвигом автоматически продвигаются к типу int,
         * поэтому после получения результата, его необходимо явно привести к первоначальному типу (byte, short, char)*/

        /* операция сдвига влево(<<)*/
        A = 34;
        res = (byte)(A << 2);
        System.out.println("сдвиг влево (A << 2): "+res);

        /* использование сдвига влево в качестве альтернативы умножению*/
        byte num1 = 4;
        System.out.print("умножение: ");
        for (int i = 0; i < 5; i++) {
            num1 = (byte)(num1 << 1);
            System.out.print(num1+" ");
        }
        System.out.println("\n- - - -");

        /* операция сдвига вправо(>>)*/
        A = 47;
        res = (byte)(A >> 2);
        System.out.println("сдвиг вправо (A >> 2): "+res);

        /* использование сдвига вправо в качестве альтернативы делению*/
        byte num2 = 64;
        System.out.print("деление: ");
        for (int i = 0; i < 5; i++) {
            num2 = (byte)(num2 >> 1);
            System.out.print(num2+" ");
        }
        System.out.println("\n- - - -");

        /* пример отбрасывания любых двоичных разрядов расширения знака*/
        char sym[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};
        byte r = (byte) 0xf1;
        System.out.println("значение r = 0xF1: "+r);
        System.out.println("результат вычисления ((r>>4)&0x0f)+(r&0x0f): "+((r>>4)&0x0f)+" и "+(r&0x0f));
        System.out.println("b = 0x"+sym[(r >> 4) & 0x0f]+sym[r & 0x0f]);
        System.out.println("- - - -");

        /* операция сдвига вправо с заполнением 1 или беззнаковый сдвиг вправо(>>>)*/
        A = 52;
        res = (byte)(A >>> 2);
        System.out.println("сдвиг вправо (A >>> 2): "+res);
        System.out.println("\n- - - -");

        /* для получения правильного результата при беззнаковом сдвиге вправо отрицательного значения
         * типа byte и short, необходимо использовать его шестнадцатеричное представление*/
        A = -52; // 0xCC - шестнадцатеричное представление значения -52 типа byte
        byte cA = (byte)0xCC;
        if (A == cA) System.out.println("true");
        /* важно отметить, что вместо беззнакового сдвига вправо используется обычный сдвиг вправо, т.к. он дает
         * тот результат, который давал бы беззнаковый сдвиг, если работал бы с типами byte и short напрямую*/
        res = (byte)(0xCC >> 2);
        System.out.println("результат: "+res);

        short B1 = -52; // 0xFFCC
        short res1 = (short)(0xFFCC >> 2);
        System.out.println("результат: "+res1);

        /* (поразрядные составные операции с присваиванием) - операции сдвига с присваиванием*/
        /* при использовании составной операции с присваиванием для типов byte и short необязательно
         * применять явное приведение*/
        int nA = 74, nB = 32;
        nA &= nB; // аналог nA = nA & nB;
        System.out.println("операция &(И) с присваиванием: "+nA);

        nA = 74; nB = 32;
        nA |= nB; // аналог nA = nA | nB;
        System.out.println("операция |(ИЛИ) с присваиванием: "+nA);

        nA = 74; nB = 32;
        nA ^= nB; // аналог nA = nA ^ nB;
        System.out.println("операция ^(Исключающее ИЛИ) с присваиванием: "+nA);

        nA = 74;
        nA <<= 7; // аналог nA = nA << 7;
        System.out.println("операция сдвиг влево << с присваиванием: "+nA);
        nA = 74;
        nA >>= 5; // аналог nA = nA >> 5;
        System.out.println("операция сдвиг вправо >> присваиванием: "+nA);
        nA = 74;
        nA >>>= 4; // аналог nA = nA >>> 4;
        System.out.println("операция беззнаковый сдвиг вправо с присваиванием: "+nA);
    }

    /*---------------------------------------------------------------------*/

    /* 2) операции отношения(сравнения)*/

    void exampleMethod2(){
        System.out.println("операции отношения(сравнения)!");
        int a = 5, b = 3;

        /* условное выражение if*/
        if(a > b){}
        System.out.println("операция > (больше) - if(A > B){}");

        /* цикл for*/
        for(int i = 0; i < a; i++) {}
        System.out.println("операция < (меньше) - for(int i = 0; i < a; i++){}");

        /* цикл while*/
        while(a >= b){
            a--;
        }
        System.out.println("операция >= (больше или равно) - while(a >= b){}");

        /* цикл do-while*/
        do{
        }while(a == b);
        System.out.println("операция == (равно) - do{}while(a == b){}");

        /* присвоение результата логической переменной*/
        boolean res = a <= b;
        System.out.println("операция <= (меньше или равно) - boolean res = a <= b");

        /* использование в методе для возвращения логического результата*/
        class MySClass{
            boolean myMeth(String str1, String str2){
                return str1 != str2;
            }
        }
        System.out.println("операция != (не равно) - boolean myMeth(String str1, String str2){return str1 != str2;}");
    }

    /*---------------------------------------------------------------------*/

    /* 3) логические операции*/

    void exampleMethod3(){
        System.out.println("Логические операции!");
        boolean A = true, B = false;
        boolean res;

        res = A & B;
        System.out.println("операция & (И) - (A & B): "+res);

        res = A | B;
        System.out.println("операция | (ИЛИ) - (A | B): "+res);

        res = A ^ B;
        System.out.println("операция ^ (Исключающее ИЛИ) - (A ^ B): "+res);

        /* составные логические операции с присваиванием*/
        A &= B;
        System.out.println("операция & (И) с присваиванием - (A &= B): "+A);

        A |= B;
        System.out.println("операция | (ИЛИ) с присваиванием - (A |= B): "+A);

        A ^= B;
        System.out.println("операция ^ (Исключающее ИЛИ) с присваиванием - (A ^= B): "+A);

        /* логическая унарная операция ! (НЕ)*/
        res = !A;
        System.out.println("операция ! (НЕ) - (!A): "+res);

        /* логические операции == (равенство и != (неравенство)*/
        res = A == B;
        System.out.println("операция == (равенство) - (A == B): "+res);

        res = A != B;
        System.out.println("операция ^ (неравенство) - (A != B): "+res);
        System.out.println("\n- - - -");

        /* укороченные логические операции && (И) и || (ИЛИ)*/
        A = true; B = false; boolean C = true;
        /* результат левого операнда true, значит будет проверяться правый операнд, т.к. результат всего выражения
         * до сих пор неясен*/
        res = (A == C && A == B);
        System.out.println("укороченная операция && (И) - результат левого операнда (true): "+res);

        /* результат левого операнда false, значит правый операнд проверяться не будет, т.к. результат всего
         * выражения, все равно будет false*/
        res = (A == B && A == C);
        System.out.println("укороченная операция && (И) - результат левого операнда (false): "+res);

        /* результат левого операнда true, значит правый операнд проверяться не будет, т.к. результат всего
         * выражения, все равно будет true*/
        res = (A == C || A == B);
        System.out.println("укороченная операция || (ИЛИ) - результат левого операнда (true): "+res);

        /* результат левого операнда false, значит будет проверяться правый операнд, т.к. результат всего выражения
         * до сих пор неясен*/
        res = (A == B || A == C);
        System.out.println("укороченная операция || (ИЛИ) - результат левого операнда (false): "+res);
        System.out.println("\n- - - -");

        /* пример укороченной логической операции && (И)*/
        System.out.println("пример использоания укороченной логической операции, проверка деления на 0(ноль)");
        int resNum, num = 34, zNum = 2;
        if(zNum != 0 && num / zNum > zNum ){
            resNum = num / zNum;
            System.out.println("деление получилось(zNUm неравен 0) - результат деления: "+resNum);
        }else{ System.out.println("ошибка деления(zNUm равен 0");}

        /* операция = (присваивания)*/
        int a, b, c;
        /* использование цепочки-присваивания для инициализации нескольких переменных одним значением*/
        a = b = b = c = 52;

        /* тернарная операция*/
        num = 47; zNum = 2;
        resNum = num == 0 ? 0 : num / zNum;
        System.out.println("тернарная операция ?: "+resNum);

        /* приме тернарной операции - абсолютное значение*/
        num = -52;
        resNum = num < 0 ? -num : num;
        System.out.println("абсолютное значение: "+resNum);

        int m = 34, n = 52, k;
        k = m >> 7 - n / 4 % 10; // без скобок
        k = m >> (7 - ((n / 4) % 10)); // со скобками
        k = ((m >> 7) - (n / 4)) % 10; // изменения последовательности
        System.out.println(k);
    }

    /*---------------------------------------------------------------------*/

    /* 4) арифметические операции*/

    void exampleMethod4(){
        System.out.println("Арифметические операции!");

        int a = 5, b = 2, c;
        c = a * b;
        System.out.println("умножение: "+c);
        c = a / b;
        System.out.println("деление: "+c+"(результатом будет целое число)");
        c = a + b;
        System.out.println("сложение: "+c);
        c = a - b;
        System.out.println("вычитание: "+c);
        c = a % b;
        System.out.println("деление по модулю: "+c);

        System.out.println("----------");

        /* составные арифметические операции, позволяют сократить вводимый код
         * и кроме этого выполняются системой эффективнее*/
        a *= b;
        System.out.println("умножение с присваиванием: "+a);
        a /= b;
        System.out.println("деление с присваиванием: "+a+"(результатом будет целое число)");
        a += b;
        System.out.println("сложение с присваиванием: "+a);
        a -= b;
        System.out.println("вычитание с присваиванием: "+a);
        a %= b;
        System.out.println("деление по модулю с присваиванием: "+a);

        System.out.println("----------");
        a = 5;
        c = +a;
        System.out.println("унарный плюс: "+c);
        b = 2;
        c = -b;
        System.out.println("унарный минус: "+c);

        /* если, при вычислении выражения получился отрицательный результат, то с помощью унарного минуса
        его можно сделать положительным*/
        c = -c;
        System.out.println("унарный минус (инверсия знака): "+c);

        /* префиксный инкремент и декремент*/
        ++a;
        --a;
        /* в выражении*/
        a = 4;
        b = ++a;
        System.out.println("префиксная форма инкремента: "+ b+" "+a);
        a = 4;
        b = --a;
        System.out.println("префиксная форма декремента: "+ b+" "+a);
        /* постфиксный инкремент и декремент*/
        b++;
        b--;
        /* в выражении*/
        a = 4;
        b = a++;
        System.out.println("постфиксная форма инкремента: "+b+" "+a);
        a = 4;
        b = a--;
        System.out.println("постфиксная форма декремента: "+b+" "+a);
        /* аналог инкремента и декремента*/
        a = a + 1; a += 1; // a++
        a = a - 1; a -= 1; // a--
    }

    /*---------------------------------------------------------------------*/

    public static void main(String[] args) {
        Operations operations = new Operations();
        operations.exampleMethod1();
        operations.exampleMethod2();
        operations.exampleMethod3();
        operations.exampleMethod4();
    }
}
