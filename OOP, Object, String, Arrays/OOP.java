package OOP;

public class OOP {

    /* A) Наследование*/

    /* Наследование – это механизм, позволяющий передавать определенные свойства и
    * поведение от родителей к их потомкам. Данный механизм позволяет поддерживать
    * принцип иерархической классификации. Например, сиамский кот относится к классу
    * кошачьих, а тот в свою очередь относится к классу млекопитающих, а тот к классу
    * животных. Без наследования, для каждого объекта пришлось бы определять все его
    * черты, независимо, повторяются ли эти черты в других объектах. Но с наследованием,
    * можно определять только те черты, которые сделают данный объект уникальным, а остальные
    * повторяющиеся, просто унаследовать.*/

    /* 1) пример 1 - наследование*/

    void exampleMethod1(){

        class A{
            int i = 1; // открытый элемент суперкласса
            private int j = 3; // закрытый элемент суперкласса
        }

        class B extends A{
            int k;
            int getSum(){
                k = i + 2; // разрешено
                //k = j + 2; // запрещено, т.к. элемент j имеет закрытый тип
                return i + k;
            }
        }

        System.out.println("- Пример 1 - наследование");
        A a = new A(); // создание объекта родительского класса
        B b = new B(); // создание объекта дочернего класса
        System.out.println(b.getSum()); // вывод на консоль
    }

    /*---------------------------------------------------------------------*/

    /* 2) пример 2 - наследование и переменная суперкласса*/

    void exampleMethod2(){

        class Animal{
            /* тип protected означает, что переменную или метод могут видеть только дочерние классы*/
            protected String color;

            protected void run(){
                System.out.println("run animal");
            }
        }

        class Cat extends Animal {
            void setColorCat(){
                color = "Black";
                run();
            }
            void setSpeed(int s){
                System.out.println(color + " : " + s);
            }
        }

        class Dog extends Animal {
            void setColorDog(){
                color = "White";
                run();
            }
            void setVoice(int voice){
                System.out.println(color + " : " + voice);
            }
        }

        System.out.println("- Пример 2 - наследование и переменная суперкласса");

        Animal animal = new Animal();

        Cat cat = new Cat();
        cat.setColorCat();
        cat.setSpeed(3);
        Dog dog = new Dog();
        dog.setColorDog();
        dog.setVoice(4);

        /* Переменная из суперкласса может ссылаться на объект подкласса*/
        animal = new Cat();
        animal = new Dog();
    }

    /*---------------------------------------------------------------------*/

    /* 3) вызов конструктора суперкласса - super*/

    void exampleMethod3(){

        class Animal{
            private final int speed;
            private final int age;

            Animal(){
                speed = -1; age = -1;
            }

            Animal(Animal an){
                speed = an.speed; age = an.age;
            }

            Animal(int s, int a){
                speed = s; age = a;
            }

            Animal(int sum){
                speed = age = sum;
            }

            int getSpeed(){
                return speed;
            }

            int getAge(){
                return age;
            }
        }

        class Cat extends Animal {
            private final int voice;

            Cat(Cat ob){
                super(ob);
                voice = ob.voice;
            }

            Cat(int s, int a, int v){
                super(s, a);
                voice = v;
            }

            Cat(){
                super();
                voice = -1;
            }

            Cat(int sum, int v){
                super(sum); voice = v;
            }

            int getVoice(){
                return voice;
            }
        }

        System.out.println("- Вызов конструктора суперкласса");

        Cat c1 = new Cat(); // по умолчанию
        Cat c2 = new Cat(12, 4); // передача 2 аргументов
        Cat c3 = new Cat(23, 34, 47); // передача 3 аргументов
        Cat c4 = new Cat(c2); // передача объекта в качестве аргумента

        System.out.println(c1.getSpeed()+" : "+c1.getAge() + " : "+c1.getVoice());
        System.out.println(c2.getSpeed()+" : "+c2.getAge() + " : "+c2.getVoice());
        System.out.println(c3.getSpeed()+" : "+c3.getAge() + " : "+c3.getVoice());
        System.out.println(c4.getSpeed()+" : "+c4.getAge() + " : "+c4.getVoice());
    }

    /*---------------------------------------------------------------------*/

    /* 4) обращение к элементу суперкласса, скрываемому элементом подкласса - super*/

    void exampleMethod4(){

        class A{
            int value; // элемент класса A
        }

        class B extends A {
            final int value; // элемент класса B скрывает элемент класса A, т.к. имеет такое же имя

            B(int a, int b){
                super.value = a; // элемент класса A
                value = b; // элемент класса B
            }

            void getValue(){
                System.out.println(super.value+" : "+value);
            }
        }

        System.out.println("- Обращение к элементу суперкласса, скрываемому элементом подкласса");

        A a = new A();
        B b = new B(34, 47);

        b.getValue();
    }

    /*---------------------------------------------------------------------*/

    /* 5) предотвращение переопределения с помощью ключевого слова final*/

    void exampleMethod5(){

        class A{
            final void meth(){
                System.out.println("Это завершенный метод");
            }
        }

        class B extends A {
            //void meth(){} // ошибка, этот метод не может быть переопределен
        }

        System.out.println("Предотвращение переопределения с помощью ключевого слова final");

        A a = new A();
        B b = new B();

    }

    /*---------------------------------------------------------------------*/

    /* 6) предотвращение наследования с помощью ключевого слова final*/

    void exampleMethod6(){

        final class A{}

        /* ошибка, класс A не может иметь подклассы*/
        class B /*extends A*/{}

        System.out.println("Предотвращение наследования с помощью ключевого слова final");

        A a = new A();
        B b = new B();

    }

    /*=====================================================================*/

    /* B) Полиморфизм*/

    /* Полиморфизм в программировании — это способность предоставлять один и
    * тот же интерфейс для различных базовых форм (типов данных). Это означает,
    * что классы, имеющие различную функциональность, совместно используют один
    * и тот же интерфейс и могут быть динамически вызваны передачей параметров по ссылке*/

    /* Переопределение методов служит основой для реализации в Java одного из самых
    * эффективных принципов – динамической диспетчеризации методов. Динамическая
    * диспетчеризация методов – это механизм, с помощью которого вызов переопределенного
    * метода разрешается во время выполнения, а не компиляции. Это дает возможность
    * реализовывать полиморфизм во время выполнения.

    * Важный принцип: ссылочная переменная из суперкласса может ссылаться на объект подкласса.
    * Этот принцип используется в Java для разрешения вызовов переопределенных методов во время
    * выполнения следующим образом: когда переопределенный метод вызывается по ссылке на суперкласс,
    * нужный вариант этого метода выбирается в Java в зависимости от типа объекта, на который
    * делается ссылка в момент вызова. Следовательно, этот выбор делается во время выполнения.
    * По ссылке на разные типы объектов будут вызываться разные варианты переопределенного метода.
    * Иначе говоря, вариант переопределенного метода выбирается для выполнения в зависимости от типа
    * объекта, на который делается ссылка, а не типа ссылочной переменной.*/

    /* 7) динамическая диспетчеризация методов*/

    void exampleMethod7(){

        class A{
            void myMeth(){ System.out.println("A"); }
        }

        class B extends A {
            /* переопределение метода суперкласса*/
            void myMeth(){ System.out.println("B"); }
        }

        class C extends A {
            /* переопределение метода суперкласса*/
            void myMeth(){ System.out.println("C"); }
        }

        System.out.println("Динамическая диспетчеризация методов");

        A r;

        r = new A();
        r.myMeth();

        r = new B();
        r.myMeth();

        r = new C();
        r.myMeth();
    }

    /*=====================================================================*/

    /* C) Инкапсуляция*/

    /* Инкапсуляция – это механизм сокрытия внутренней реализации каждой части программы.
    * Процесс инкапсуляции осуществляется путем контролирования уровня доступа к данным
    * и коду программы. Для этого используется следующие модификаторы: public, protected и private.
    *
    *   - Public (открытый, публичный) – это модификатор, при котором доступ к элементам
    * (у которых он указан), осуществляется из любой части программы.
    *
    *   - Protected (защищенный) – это модификатор, при котором доступ к элементам
    * (у которых он указан), осуществляется только в пределах папки, где они находятся, а также они
    * доступны элементам, являющимися их наследниками***, которые могут находится в других папках.
    *
    *   - Private (закрытый, приватный) – это модификатор, при котором доступ к элементам
    * (у которых он указан), осуществляется только в пределах класса*, где они находятся.
    *
    *   - Также существует доступ по умолчанию (пакетный** доступ). У него нет модификатора.
    * При этом доступ к элементам (у которых нет модификатора), осуществляется только в
    * пределах папки, где они находятся.
    *
    * Примечание:
    * "*" Класс – это некая “схема” того из чего состоит объект. Т.е. объект – это физическое
    * представление чего-либо, а класс описывает, то из чего этот объект будет состоять.
    * При создании объекта, может использоваться несколько классов.
    * "**" Пакет - это папка, в котором хранятся классы, описывающие объект.
    * "***" Наследники – это классы, у которых есть возможность перенять себе черты
    * от классов-родителей. О наследниках и наследовании будет изложено далее.*/

    void exampleMethod8(){

        class Example{
            public int a; // виден всем объектам
            int b; // виден только объектам находящимся в том же пакете
            protected int c; // виден только объектам находящимся в том же пакете и всем, кто является наследником
            private int d; // виден только самому объекту
        }

        class Example1{
            private int a; // сокрытие полей класса

            /* определение открытых методов для доступа к скрытым полям*/
            public void setA(int a){
                this.a = a;
            }

            public int getA(){
                return this.a;
            }
        }
    }


    /*=====================================================================*/

    /* D) Абстракция*/

    /* Абстракция – это процесс представления чего-либо (явления или объекта),
    с целью упростить понимание его внешнего вида и действий, которые он совершает.
    Эффективным способом абстракции является иерархическая классификация (глубокая абстракция).
    Это способ при котором сложная система разбивается на мелкие, контролируемые его части,
    а те, в свое очередь, еще на более мелкие. Примером может послужить автомобиль.
    Он как внешне единый объект, может быть разделен на более мелкие объекты,
    например: рулевое управление, тормозная система, двигатель и т.д. И каждый его мелкий объект,
    также может быть разделен на более мелкие объекты (например: тормозная система
    может быть разделена на педаль тормоза, тормозные колодки и т.д.)*/

    public static void main(String[] args) {
        OOP oop = new OOP();
        oop.exampleMethod1();
        oop.exampleMethod2();
        oop.exampleMethod3();
        oop.exampleMethod4();
        oop.exampleMethod5();
        oop.exampleMethod6();
        oop.exampleMethod7();
        oop.exampleMethod8();
    }
}
